package util;

import lombok.extern.slf4j.Slf4j;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Random;

/**
 * Utility class for generating unique identifiers (SUIDs) in a Stripe-like style.
 */
@Slf4j
public class SUID {
    // Allowable characters for the shortened URL
    private static final char[] BASE_62_CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".toCharArray();
    private static final int PAYLOAD_SIZE = 28;
    private static final int MAX_LENGTH = 10;
    private static final Random RANDOM = new SecureRandom();

    /**
     * Generates a unique identifier with a specified prefix and a default length of 10 characters.
     *
     * @param prefix the prefix to be added to the generated identifier
     * @return the generated unique identifier
     */
    public static String generate(String prefix) {
        return generate(prefix, 10);
    }

    /**
     * Generates a unique identifier with a specified prefix and length.
     *
     * @param prefix the prefix to be added to the generated identifier
     * @param length the length of the generated identifier (excluding the prefix)
     * @return the generated unique identifier
     * @throws IllegalArgumentException if the specified length exceeds the maximum allowed length
     */
    public static String generate(String prefix, int length) {
        if (length > MAX_LENGTH) {
            throw new IllegalArgumentException("SUID cannot be longer than " + MAX_LENGTH + " characters + prefix");
        }
        String encoded = base62Encode(generateRandomBytes(PAYLOAD_SIZE));
        return (prefix + "_" + encoded).substring(0, Math.min(prefix.length() + 1 + length, encoded.length()));
    }

    /**
     * Generates a byte array of the specified size filled with random bytes.
     *
     * @param size the size of the byte array to generate
     * @return the generated byte array
     */
    private static byte[] generateRandomBytes(int size) {
        byte[] bytes = new byte[size];
        RANDOM.nextBytes(bytes);
        return bytes;
    }

    /**
     * Encodes the given byte array into a Base62 string.
     *
     * @param bytes the byte array to encode
     * @return the Base62 encoded string
     */
    private static String base62Encode(byte[] bytes) {
        BigInteger number = new BigInteger(1, bytes);
        StringBuilder result = new StringBuilder();
        while (number.compareTo(BigInteger.ZERO) > 0) {
            int remainder = number.mod(BigInteger.valueOf(BASE_62_CHARACTERS.length)).intValue();
            result.append(BASE_62_CHARACTERS[remainder]);
            number = number.divide(BigInteger.valueOf(BASE_62_CHARACTERS.length));
        }
        return result.reverse().toString();
    }
}